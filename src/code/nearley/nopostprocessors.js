// Generated automatically by nearley, version 2.19.3
// http://github.com/Hardmath123/nearley
(function () {
function id(x) { return x[0]; }

const moo = require("moo")
const lexer = moo.compile([

    {type: "COMMENT", match: /\/\*[\W\w]*?\*\//, value: x => x.slice(2, -3)},
    {type: "COMMENT", match: /\/{2}(?:.*?)\n?$/, value: x => x.slice(2)},

    {type: "SPACE", match: /\s+/, lineBreaks: true},
    {type: "DELIMITER", match: ";"},

    {type: "STRING",  match: /".*?"/, value: x => JSON.parse(x)},
    {type: "STRING",  match: /'.*?'/, value: x => JSON.parse('"' + x.slice(1, -1) + '"')},
    {type: "NUMBER",  match: /-?(?:[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)/, value: x => Number(x)},
    {type: "NUMBER",  match: /-?[1-9]\d*/, value: x => Number(x)},
    {type: "NUMBER",  match: /0x[0-9A-Fa-f]+/, value: x => parseInt(x)},
    {type: "NUMBER",  match: /0b[01]+/, value: x => parseInt(x)},
    {type: "NUMBER",  match: /0[0-7]+/, value: x => parseInt(x)},
    {type: "COLOR",   match: /#[A-Fa-f0-9]{3}(?:[A-Fa-f0-9](?:[A-Fa-f0-9]{2}(?:[A-Fa-f0-9]{2})))?/},

    {type: "COMMA", match: ","},
    {type: "LP", match: "("},
    {type: "RP", match: ")"},
    {type: "LMP", match: "["},
    {type: "RMP", match: "]"},
    {type: "LCB", match: "{"},
    {type: "RCB", match: "}"},
    {type: "GT", match: ">"},
    {type: "LT", match: "<"},
    {type: 'OP', match: /[&|\=\.]{2}|[\+\-\*\/\%\!\<\>=]/},

    // Keywords
    {type: "KW_VAR", match: "var"},
    {type: "KW_IN", match: "in"},
    {type: "KW_LET", match: "let"},
    {type: "KW_WHEN", match: "when"},
    {type: "KW_DEFINE", match: "define"},
    {type: "KW_ATONCE", match: "atonce"},
    {type: "KW_END", match: "end"},
    {type: "KW_WHILE", match: "while"},
    {type: "KW_FOREVER", match: "forever"},
    {type: "KW_REPEAT", match: "repeat"},
    {type: "KW_REGISTER", match: "register"},
    {type: "KW_IF", match: "if"},
    {type: "KW_ELSE", match: "else"},
    {type: "KW_USING", match: "using"},
    {type: "KW_NUMBER", match: "number"},
    {type: "KW_STRING", match: "string"},
    {type: "KW_BOOL", match: "bool"},

    {type: "BLOCKIDEN", match: /[a-zA-Z_][0-9a-zA-Z_]*\.[a-zA-Z_][0-9a-zA-Z_]*/},
    {type: "IDEN", match: /[a-zA-Z_][0-9a-zA-Z_]*/},

    {type: 'UIDEN', match: /[^\n \t"'()<>=*\/+-]+/},
    {type: "ERROR", error: true},
])
var grammar = {
    Lexer: lexer,
    ParserRules: [
    {"name": "Program", "symbols": ["_", "_Program", "_"]},
    {"name": "_Program", "symbols": ["OutsideStatement"]},
    {"name": "_Program$subexpression$1", "symbols": ["_", {"literal":";"}, "_"]},
    {"name": "_Program$subexpression$1", "symbols": ["__"]},
    {"name": "_Program", "symbols": ["_Program", "_Program$subexpression$1", "OutsideStatement"]},
    {"name": "OutsideStatement", "symbols": ["Comment"]},
    {"name": "OutsideStatement", "symbols": ["RegisterStatement"]},
    {"name": "OutsideStatement", "symbols": ["UsingStatement"]},
    {"name": "OutsideStatement", "symbols": ["VariableDefinition"]},
    {"name": "OutsideStatement", "symbols": ["FunctionDefinition"]},
    {"name": "OutsideStatement", "symbols": ["EventListener"]},
    {"name": "RegisterStatement$subexpression$1", "symbols": ["__", {"literal":"as"}, "__", (lexer.has("IDEN") ? {type: "IDEN"} : IDEN)]},
    {"name": "RegisterStatement$subexpression$1", "symbols": []},
    {"name": "RegisterStatement", "symbols": [{"literal":"register"}, "__", (lexer.has("STRING") ? {type: "STRING"} : STRING), "RegisterStatement$subexpression$1"]},
    {"name": "UsingStatement", "symbols": [{"literal":"using"}, "__", (lexer.has("STRING") ? {type: "STRING"} : STRING)]},
    {"name": "Block", "symbols": ["_", "_Block", "_"]},
    {"name": "Block", "symbols": ["_"]},
    {"name": "_Block", "symbols": ["Statement"]},
    {"name": "_Block", "symbols": ["_Block", "_", "Statement"]},
    {"name": "Statement$subexpression$1", "symbols": ["_", {"literal":";"}]},
    {"name": "Statement$subexpression$1", "symbols": []},
    {"name": "Statement", "symbols": ["_Statement", "Statement$subexpression$1"]},
    {"name": "_Statement", "symbols": ["Comment"]},
    {"name": "_Statement", "symbols": ["RepeatCondition"]},
    {"name": "_Statement", "symbols": ["SetVariable"]},
    {"name": "_Statement", "symbols": ["WhileCondition"]},
    {"name": "_Statement", "symbols": ["IfCondition"]},
    {"name": "_Statement", "symbols": ["FunctionCall"]},
    {"name": "EventListener", "symbols": [{"literal":"when"}, "__", (lexer.has("BLOCKIDEN") ? {type: "BLOCKIDEN"} : BLOCKIDEN), "_", {"literal":"("}, "ArgList", {"literal":")"}, "_", "FunctionBody"]},
    {"name": "FunctionDefinition$subexpression$1", "symbols": [(lexer.has("KW_ATONCE") ? {type: "KW_ATONCE"} : KW_ATONCE), "__"]},
    {"name": "FunctionDefinition$subexpression$1", "symbols": []},
    {"name": "FunctionDefinition", "symbols": ["FunctionDefinition$subexpression$1", (lexer.has("KW_DEFINE") ? {type: "KW_DEFINE"} : KW_DEFINE), "__", (lexer.has("IDEN") ? {type: "IDEN"} : IDEN), "_", {"literal":"("}, "_", "ParamList", "_", {"literal":")"}, "_", "FunctionBody"]},
    {"name": "FunctionCall$subexpression$1", "symbols": [(lexer.has("BLOCKIDEN") ? {type: "BLOCKIDEN"} : BLOCKIDEN)]},
    {"name": "FunctionCall$subexpression$1", "symbols": [(lexer.has("IDEN") ? {type: "IDEN"} : IDEN)]},
    {"name": "FunctionCall", "symbols": ["FunctionCall$subexpression$1", "_", {"literal":"("}, "ArgList", {"literal":")"}, "InCases"]},
    {"name": "VariableDefinition", "symbols": ["_VariableDefinition"]},
    {"name": "_VariableDefinition", "symbols": [{"literal":"var"}, "__", "VariableName"]},
    {"name": "_VariableDefinition", "symbols": [{"literal":"var"}, "__", "VariableName", "_", {"literal":"="}, "_", "Constant"]},
    {"name": "_VariableDefinition", "symbols": [{"literal":"var"}, "__", "VariableName", "_", {"literal":"="}, "_", "ListConstant"]},
    {"name": "_VariableDefinition", "symbols": [{"literal":"let"}, "__", "VariableName"]},
    {"name": "_VariableDefinition", "symbols": [{"literal":"let"}, "__", "VariableName", "_", {"literal":"="}, "_", "Constant"]},
    {"name": "_VariableDefinition", "symbols": [{"literal":"let"}, "__", "VariableName", "_", {"literal":"="}, "_", "ListConstant"]},
    {"name": "VariableName$subexpression$1", "symbols": [(lexer.has("IDEN") ? {type: "IDEN"} : IDEN)]},
    {"name": "VariableName$subexpression$1", "symbols": [(lexer.has("BLOCKIDEN") ? {type: "BLOCKIDEN"} : BLOCKIDEN)]},
    {"name": "VariableName", "symbols": ["VariableName$subexpression$1"]},
    {"name": "IfCondition", "symbols": [{"literal":"if"}, "_", {"literal":"("}, "_", "Expression", "_", {"literal":")"}, "_", "FunctionBody"]},
    {"name": "IfCondition", "symbols": [{"literal":"if"}, "_", {"literal":"("}, "_", "Expression", "_", {"literal":")"}, "_", "FunctionBody", "_", {"literal":"else"}, "_", "FunctionBody"]},
    {"name": "WhileCondition", "symbols": [{"literal":"forever"}, "_", "FunctionBody"]},
    {"name": "WhileCondition", "symbols": [(lexer.has("KW_WHILE") ? {type: "KW_WHILE"} : KW_WHILE), "_", {"literal":"("}, "_", "Expression", "_", {"literal":")"}, "_", "FunctionBody"]},
    {"name": "RepeatCondition", "symbols": [{"literal":"repeat"}, "_", {"literal":"("}, "_", "Expression", "_", {"literal":")"}, "_", "FunctionBody"]},
    {"name": "ArgList", "symbols": []},
    {"name": "ArgList", "symbols": ["_", "ExpList", "_"]},
    {"name": "InCases", "symbols": []},
    {"name": "InCases", "symbols": ["_", "_InCases"]},
    {"name": "_InCases", "symbols": ["InCase"]},
    {"name": "_InCases", "symbols": ["_InCases", "__", "InCase"]},
    {"name": "InCase", "symbols": [{"literal":"in"}, "__", "Constant", "__", "FunctionBody"]},
    {"name": "ParamList", "symbols": []},
    {"name": "ParamList", "symbols": ["Param"]},
    {"name": "ParamList", "symbols": ["ParamList", "_", {"literal":","}, "_", "Param"]},
    {"name": "Param$ebnf$1$subexpression$1$subexpression$1", "symbols": [{"literal":"string"}]},
    {"name": "Param$ebnf$1$subexpression$1$subexpression$1", "symbols": [{"literal":"number"}]},
    {"name": "Param$ebnf$1$subexpression$1$subexpression$1", "symbols": [{"literal":"bool"}]},
    {"name": "Param$ebnf$1$subexpression$1", "symbols": ["_", {"literal":":"}, "_", "Param$ebnf$1$subexpression$1$subexpression$1"]},
    {"name": "Param$ebnf$1", "symbols": ["Param$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "Param$ebnf$1", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "Param", "symbols": [(lexer.has("IDEN") ? {type: "IDEN"} : IDEN), "Param$ebnf$1"]},
    {"name": "FunctionBody", "symbols": [{"literal":"{"}, "Block", {"literal":"}"}]},
    {"name": "SetVariable", "symbols": [(lexer.has("IDEN") ? {type: "IDEN"} : IDEN), "_", {"literal":"="}, "_", "Expression"]},
    {"name": "ExpList", "symbols": ["Expression"]},
    {"name": "ExpList", "symbols": ["ExpList", "_", {"literal":","}, "_", "Expression"]},
    {"name": "Expression", "symbols": ["ExpOr"]},
    {"name": "Parenthesized", "symbols": [{"literal":"("}, "Expression", {"literal":")"}]},
    {"name": "ExpOr", "symbols": ["ExpOr", "_", {"literal":"||"}, "_", "ExpAnd"]},
    {"name": "ExpOr", "symbols": ["ExpAnd"]},
    {"name": "ExpAnd", "symbols": ["ExpAnd", "_", {"literal":"&&"}, "_", "ExpComparison"]},
    {"name": "ExpAnd", "symbols": ["ExpComparison"]},
    {"name": "ExpComparison", "symbols": ["ExpComparison", "_", {"literal":">"}, "_", "ExpConcatenation"]},
    {"name": "ExpComparison", "symbols": ["ExpComparison", "_", {"literal":"<"}, "_", "ExpConcatenation"]},
    {"name": "ExpComparison", "symbols": ["ExpEquals"]},
    {"name": "ExpEquals", "symbols": ["ExpComparison", "_", {"literal":"=="}, "_", "ExpConcatenation"]},
    {"name": "ExpEquals", "symbols": ["ExpConcatenation"]},
    {"name": "ExpConcatenation", "symbols": ["ExpConcatenation", "_", {"literal":".."}, "_", "ExpSum"]},
    {"name": "ExpConcatenation", "symbols": ["ExpSum"]},
    {"name": "ExpSum", "symbols": ["ExpSum", "_", {"literal":"+"}, "_", "ExpProduct"]},
    {"name": "ExpSum", "symbols": ["ExpSum", "_", {"literal":"-"}, "_", "ExpProduct"]},
    {"name": "ExpSum", "symbols": ["ExpProduct"]},
    {"name": "ExpProduct", "symbols": ["ExpProduct", "_", {"literal":"*"}, "_", "ExpSum"]},
    {"name": "ExpProduct", "symbols": ["ExpProduct", "_", {"literal":"/"}, "_", "ExpSum"]},
    {"name": "ExpProduct", "symbols": ["ExpProduct", "_", {"literal":"%"}, "_", "ExpSum"]},
    {"name": "ExpProduct", "symbols": [{"literal":"!"}, "_", "ExpSum"]},
    {"name": "ExpProduct", "symbols": ["Atom"]},
    {"name": "Atom", "symbols": [{"literal":"null"}]},
    {"name": "Atom", "symbols": [(lexer.has("IDEN") ? {type: "IDEN"} : IDEN)]},
    {"name": "Atom", "symbols": [(lexer.has("BLOCKIDEN") ? {type: "BLOCKIDEN"} : BLOCKIDEN)]},
    {"name": "Atom", "symbols": ["Constant"]},
    {"name": "Atom", "symbols": ["Parenthesized"]},
    {"name": "Atom", "symbols": ["FunctionCall"]},
    {"name": "ListConstant", "symbols": [{"literal":"["}, "_", "ListItems", "_", {"literal":"]"}]},
    {"name": "ListConstant", "symbols": [{"literal":"["}, "_", {"literal":"]"}]},
    {"name": "ListItems", "symbols": ["Constant"]},
    {"name": "ListItems", "symbols": ["ListItems", "_", {"literal":","}, "_", "Constant"]},
    {"name": "Constant", "symbols": [(lexer.has("STRING") ? {type: "STRING"} : STRING)]},
    {"name": "Constant", "symbols": [(lexer.has("COLOR") ? {type: "COLOR"} : COLOR)]},
    {"name": "Constant", "symbols": [(lexer.has("NUMBER") ? {type: "NUMBER"} : NUMBER)]},
    {"name": "_", "symbols": []},
    {"name": "_", "symbols": ["_", "Comment", "_"]},
    {"name": "_", "symbols": [(lexer.has("SPACE") ? {type: "SPACE"} : SPACE)]},
    {"name": "__", "symbols": ["_", "Comment", "_"]},
    {"name": "__", "symbols": [(lexer.has("SPACE") ? {type: "SPACE"} : SPACE)]},
    {"name": "Comment", "symbols": [(lexer.has("COMMENT") ? {type: "COMMENT"} : COMMENT)]}
]
  , ParserStart: "Program"
}
if (typeof module !== 'undefined'&& typeof module.exports !== 'undefined') {
   module.exports = grammar;
} else {
   window.grammar = grammar;
}
})();
