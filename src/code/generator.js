const uid = require('./uid')
const CoreBlocks = require('./blocks/index')
const InputType = require('./inputType')
const BlockType = require('./blockType')

/* SUBSTACK + num */

/**
 *
 * @typedef {number} ShadowType Does this block is not a part of the parent?
 * @typedef {string} BlockId The block id.
 * @typedef {[number, string | number | null]} Constant
 * @typedef {string | null} BlockShadow The shadow block id.
 * @typedef {[ShadowType, BlockId | Constant, BlockShadow]} Input A block's input.
 * @typedef {Object.<string, Input>} Inputs A block's inputs, contains constants or blocks.
 *
 * @typedef {string} FieldValue The value of the field, if is variable it will be the name of it.
 * @typedef {string | null} FieldId The value of the field, if is variable it will be the name of it.
 * @typedef {[FieldValue, FieldId]} Field A block's field.
 * @typedef {Object.<string, Field>} Fields A block's fields, contains variables or menus.
 *
 * @typedef {Object} Block A block data.
 * @property {string} opcode
 * @property {string | null} next
 * @property {string | null} parent
 * @property {Inputs} inputs
 * @property {Fields} fields
 * @property {boolean} shadow
 * @property {boolean} topLevel
 * @property {number} x
 * @property {number} y
 *
 * @typedef {Object.<string, Block>} Blocks A object contains all the blocks.
 */

class BlocksHelper {
    /**
     * Generate a helper to make blocks operation easier.
     * @param {Blocks} blocks
     * @param {*} ast
     */
    constructor (blocks, ast) {
        this._blocks = blocks
        this._ast = ast
    }

    /**
     * @param {Block} block
     */
    saveBlock (block) {
        const id = uid()
        this._blocks[id] = block
        return id
    }

    /**
     * @param {Block} block
     * @returns {Block}
     */
    getTopBlock (block) {
        let temp = this._blocks[block.parent]
        while (temp.parent !== null) {
            temp = this._blocks[temp.parent]
        }
        return temp
    }

    /**
     * @returns {{block: Block, id: string}}
     */
    newBlock () {
        const block = {
            opcode: '',
            next: null,
            parent: null,
            inputs: {},
            fields: {},
            shadow: false,
            topLevel: false,
            x: 0,
            y: 0
        }
        return { block, id: this.saveBlock(block) }
    }

    /**
     * @param {object} block The block object
     * @param {Object.<string,[string, string]>} block.fields The block's fields
     * @param {string} name
     * @param {string | number} value
     * @param {*} isVariable
     */
    setField (block, name, value, isVariable = false) {
        block.fields[name] = [value, null]
        if (isVariable) {
            const variable = this._ast.variables.find(v => v.name === name)
            if (!variable) throw new TypeError(`Undefined variable ${name}`)
            block.fields[name][1] = variable.id
        }
    }

    /**
     * @param {object} block The block object
     * @param {Object.<string,[string, string]>} block.fields The block's fields
     * @param {string} name
     * @param {string | number} value
     * @param {*} isVariable
     */
    setInput (block, name, value, isVariable = false) {
        block.fields[name] = [value, null]
        if (isVariable) {
            const variable = this._ast.variables.find(v => v.name === name)
            if (!variable) throw new TypeError(`Undefined variable ${name}`)
            block.fields[name][1] = variable.id
        }
    }
}

/**
 * @enum {ShadowType}
 */
const ShadowType = {
    /**
     * Which will move with parent block when draging
     */
    SameShadow: 1,
    /**
     * 2
     */
    NoShadow: 2,
    /**
     * 3
     */
    DifferentShadow: 3
}

class CompileError extends TypeError {
    constructor (msg, node) {
        super(msg)
        this.node = node
        this.type = 'CompileError'
    }
}

const te = (msg, node) => new CompileError(msg, node)

const substack = num => `SUBSTACK${num > 1 ? num : ''}`

const nonMenus = [
    InputType.Number,
    InputType.Angle,
    InputType.String,
    InputType.PositionInteger,
    InputType.PositiveNumber,
    InputType.Color,
    InputType.Integer
]

/**
 * Generate blocks object from the ast.
 * @param {import('./parser').AST} ast The AST object that generated by parser.
 * @returns {any} The block object.
 */
function generator (
    ast,
    blocks = {},
    optimizeLevel = 0,
    askForModule = () => { throw new Error('This caller doesn\'t supplied module resolve function.') }
) {
    const helper = new BlocksHelper(blocks, ast)
    /**
     * @param {import('./parser').Node} node
     * @param {string?} parentId
     * @returns {string | import('./parser').Constant} The block's id
     */
    function generate (node, parentId = null) {
        switch (node.type) {
        case 'UsingStatement':
        {
            return askForModule()
        }
        case 'FunctionDefintion':
        {
            // TODO
            return null
        }
        case 'EventExpression':
        {
            const blockd = CoreBlocks.getBlock(node.name, node.args.length)
            if (!blockd || blockd.type !== BlockType.EventBlock) {
                throw te(`Can't find event ${node.name} with ${node.args.length} argument${node.args.length > 1 ? 's' : ''}`, node)
            }
            const evtBlock = helper.newBlock()
            const block = evtBlock.block
            block.opcode = blockd.opcode
            block.topLevel = true
            let parentBlockId = evtBlock.id
            for (const statement of node.body) {
                const temp = generate(statement, parentBlockId)
                if (temp) {
                    if (parentBlockId === evtBlock.id) {
                        parentBlockId = temp
                        block.next = parentBlockId
                    } else {
                        blocks[parentBlockId].next = temp
                        parentBlockId = blocks[parentBlockId].next
                    }
                }
            }
            return evtBlock.id
        }
        case 'FunctionCall':
        {
            const blockd = CoreBlocks.getBlock(node.name, node.args.length)
            if (!(blockd && [
                BlockType.Block,
                BlockType.ReporterBlock,
                BlockType.BooleanReporter
            ].includes(blockd.type))) {
                throw te(`Can't find block ${node.name} with ${node.args.length} argument${node.args.length > 1 ? 's' : ''}`, node)
            }
            let isAllConstants = true
            for (let i = 0; i < blockd.args.length; i++) {
                if (node.args[i].type !== 'Constant') {
                    isAllConstants = false
                    break
                }
            }
            if (isAllConstants && blockd.preprocess && blockd.subn === 0 && optimizeLevel > 0) {
                return blockd.preprocess(node, helper)
            } else {
                const funcBlock = helper.newBlock()
                const block = funcBlock.block
                block.opcode = blockd.opcode
                block.parent = parentId
                for (let i = 0; i < blockd.args.length; i++) {
                    const arg = blockd.args[i]
                    const narg = node.args[i]
                    const defaultValue = ({
                        [InputType.Boolean]: null,
                        [InputType.Broadcast]: null,
                        [InputType.List]: null,
                        [InputType.Menu]: null,
                        [InputType.Variable]: null,
                        [InputType.Color]: '#000000',
                        [InputType.String]: '',
                        [InputType.Integer]: 0,
                        [InputType.PositionInteger]: 0,
                        [InputType.PositiveNumber]: 0,
                        [InputType.Number]: 0
                    })[arg.type]
                    if (narg.type === 'Constant') {
                        if (nonMenus.includes(arg.type)) {
                            block.inputs[arg.name] = [defaultValue !== null ? ShadowType.DifferentShadow : ShadowType.NoShadow, null, [arg.type, narg.value]]
                        } else {
                            // So we think it's a menu
                            if (arg.type === InputType.Variable) {
                                if (narg.type !== 'Constant') throw te(`Can't use non-constant to argument ${i} in block ${node.name}`, narg)
                                const variable = ast.variables.find(v => v.name === narg.value)
                                if (!variable) throw te(`Undefined variable ${narg.value}`, narg)
                                if (!variable.islocal) variable.used.push([funcBlock.id, 'input', arg.name, '1', '2'])
                                block.fields[arg.name] = [variable.name, variable.id]
                            }
                        }
                    } else {
                        const subBlock = generate(narg, funcBlock.id)
                        if (typeof subBlock !== 'string') {
                            // It is constants, or array (variable or list)
                            if (subBlock instanceof Array) {
                                if (defaultValue === null) {
                                    block.inputs[arg.name] = [ShadowType.NoShadow, subBlock]
                                } else {
                                    block.inputs[arg.name] = [ShadowType.DifferentShadow, null, subBlock]
                                }
                            } else if (nonMenus.includes(arg.type)) {
                                block.inputs[arg.name] = [ShadowType.DifferentShadow, null, [arg.type, narg.value]]
                            } else {
                                // So we think it's a menu
                                if (arg.type === InputType.Variable) {
                                    if (narg.type !== 'Constant') throw te(`Can't use non-constant to argument ${i} in block ${node.name}`, narg)
                                    const variable = ast.variables.find(v => v.name === narg.value)
                                    if (!variable) throw te(`Undefined variable ${narg.value}`, narg)
                                    if (!variable.islocal) variable.used.push([funcBlock.id, 'input', arg.name, '1', '2'])
                                    block.fields[arg.name] = [InputType.Variable, variable.name, variable.id]
                                }
                            }
                        } else {
                            if (defaultValue === null) {
                                block.inputs[arg.name] = [ShadowType.NoShadow, subBlock]
                            } else {
                                block.inputs[arg.name] = [ShadowType.DifferentShadow, subBlock, [arg.type, defaultValue]]
                            }
                        }
                    }
                }
                // Check if block has substack
                for (let i = 1; i <= blockd.subn; i++) {
                    const thisCase = node.cases.find(v => v.name && v.name.value === i)
                    const inputName = substack(i)
                    block.inputs[inputName] = [ShadowType.NoShadow, null]
                    // If they have something in this substack
                    if (thisCase) {
                        let parentBlockId = funcBlock.id
                        for (const statement of thisCase.body) {
                            const temp = generate(statement, parentBlockId)
                            if (temp) {
                                if (parentBlockId === funcBlock.id) {
                                    parentBlockId = temp
                                    block.inputs[inputName][1] = parentBlockId
                                } else {
                                    blocks[parentBlockId].next = temp
                                    parentBlockId = blocks[parentBlockId].next
                                }
                            }
                        }
                    }
                }
                return funcBlock.id
            }
        }
        case 'Literal':
        {
            const variable = ast.variables.find(v => v.name === node.name)
            if (!variable) throw te(`Undefined variable ${node.name}`, node)
            return [InputType.Variable, variable.name, variable.id]
        }
        case 'Comment':
        {
            // TODO
            return null
        }
        default:
            throw new SyntaxError(`Unknown AST node type ${node.type}`)
        }
    }
    // Give variables a uid for indexing.
    ast.variables.forEach(v => { v.id = uid(); v.used = [] })
    ast.procedures.forEach((node) => { generate(node) })
    ast.listeners.forEach((node) => { generate(node) })
    return {
        blocks,
        ast
    }
}

module.exports = generator
